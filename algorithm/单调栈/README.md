# 单调栈

## 解决问题

> 在一个数组中，得到每个位置，左/右边离它最近的，比它小的数在哪。要是时间复杂度O(N)

- 问题1： 重复值怎么兼顾
- 问题2： 时间复杂度是怎么算出来的


## [题目1——LC84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

- 思路1: 当我们选定一个矩形的时候，高是由这个范围内高度最小的柱子，宽是这个最小柱子左右两边比它高的柱子的范围。

- 思路2: 那么，我们枚举每个柱子，看以它做为高，它的宽最高能是多长即可。



## [题目2——LC.1856. 子数组最小乘积的最大值](https://leetcode.cn/problems/maximum-subarray-min-product/description/)

- 思路1: 子数组的和，涉及到前缀和

- 思路2: 子数组的和 * 子数组中的最小值。我们可以枚举最小值，得出每个位置的最小值的最大子数组是什么即可。


## [题目3——LC.85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

- 思路1： 矩形有行和列。若我们以每一行作为基础，再去思考问题看下此时是否是题目1类似。


## [题目4——LC.1504. 统计全1子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/description/)

- 为什么要以每一行做底：11:38

- 思路1: 其实还是同题目3，只不过在求最大值时改为计算子矩形

- 思路2: 怎么计算子矩形数量？假设有一个数组 [5, 1, 4, 2, 2, 1]
  
  - 轮到5.它右边的最小值是1， 所以它可以提供高度5,4，3,2,1的子矩形各一个。
  - 轮到4.它两边的最小是是2，所以它可以提供高度4,3 的子矩形 各1个。
  - 轮到2， 它两边最小值是1， 所以只能提供2的高度。但是范围是2格，所以能提供 2 * （2 +1）/ 2。
  - 轮到1. 提供1高度，范围5个，就有 5 * (5 + 1) /2 = 15个


## [题目5—-计算被包裹的货物数量] 
```js
一个字符串s，表示仓库的墙 与 货物，其中'|'表示墙,'*'表示货物。
给定一个起始下标start和一个终止下标end，
找出子串中 被墙包裹的货物 数量
比如
s = "|**|**|*"
start = 1, end = 7
start和end截出的子串是 "**|**|*"
被 '|'包裹的 '*' 有两个，所以返回2
现在给定一系列的start，startIndices[]，和对应一系列的end ,endIndices[]
返回每一对[start,end]的截出来的货物数量
数据规模：
字符串s长度<=10^5
startIndices长度 == endIndices长度 <=10^5
```

- 思路1: 找到start右边最近的 |。 找到 end 左边最近的 | 。 计算这两个间的差异即可

- 思路2: 怎么转换成单调栈？。只需要生成每个位置，左边最近的 | 在哪。 右边最近的在哪即可。